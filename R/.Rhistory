# Get the ID of the clicked county.  The returned ID will be
# the layerId specified in the first addPolygons call - in this
# case the value of the NAME field for the clicked county.
county_click <- eventReactive(input$map_shape_click, {
x <- input$map_shape_click
y <- x$id
return(y)
})
# Here, we update our drop-down menu based on the county clicked.
observe({
updateSelectInput(session, 'county', selected = county_click())
})
# Here, we generate a new map based on the county click.  We remove the old
# highlighted county, then add the new one using the same styling we did before.
observe({
wamap <- leafletProxy('map', session) %>%
removeShape('sel_cty') %>%
addPolygons(data = selected_county(), fill = FALSE, color = '#FFFF00',
opacity = 1, layerId = 'sel_cty') %>%
fitBounds(lng1 = bbox(selected_county())[1],
lat1 = bbox(selected_county())[2],
lng2 = bbox(selected_county())[3],
lat2 = bbox(selected_county())[4])
})
# This is just an example of the output that can be generated.
# As you've changed the value for NAME - in this case the
# name of the county - it could be passed to a reactive expression to subset another
# dataset by county and then create a custom county plot.
output$expression <- renderPrint({
paste0('You clicked on ', input$county, '!  Pass me to a reactive expression!')
})
}
# Run the application
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
wa <- counties('WA', cb = TRUE, resolution = '20m')
library(shiny)
library(leaflet)
library(tigris)
library(sp)
install.packages("tigris")
install.packages("sp")
library(shiny)
library(leaflet)
library(tigris)
library(sp)
wa <- counties('WA', cb = TRUE, resolution = '20m')
library(shiny)
# requires the dev version of leaflet; devtools::install_github('rstudio/leaflet')
library(leaflet)
library(tigris)
library(sp)
# Using counties in Washington here from the tigris package; any spatial data frame in WGS84
# will do!  (Also NAD83 works fine, that's what the Census shapefiles use)
wa <- counties('WA', cb = TRUE, resolution = '20m')
ui <- fluidPage(
titlePanel("Leaflet map as selectInput"),
sidebarLayout(
sidebarPanel(
selectInput('county',
'Select a county:',
# Using the county name as the common ID here; be sure
# to keep this consistent across your app
choices = sort(wa$NAME),
selected = 'King'),
leafletOutput('map')
),
mainPanel(
verbatimTextOutput('expression')
)
)
)
server <- function(input, output, session) {
# Here, grab a single county based on user input
selected_county <- reactive({
s <- wa[wa$NAME == input$county, ]
return(s)
})
output$map <- renderLeaflet({
wamap <- leaflet() %>%
addProviderTiles('CartoDB.Positron') %>%
# First add all of the counties...
addPolygons(data = wa, weight = 1, smoothFactor = 0.2, color = '#00008B',
fillColor = '#00008B', label = ~NAME,
layerId = ~NAME) %>%
# ... then superimpose the outline of the selected county in a different color - I'm using yellow.
addPolygons(data = selected_county(), fill = FALSE, color = '#FFFF00',
opacity = 1, layerId = 'sel_cty') %>%
# Zoom to the bounds of the selected county
fitBounds(lng1 = bbox(selected_county())[1],
lat1 = bbox(selected_county())[2],
lng2 = bbox(selected_county())[3],
lat2 = bbox(selected_county())[4])
wamap
})
# Get the ID of the clicked county.  The returned ID will be
# the layerId specified in the first addPolygons call - in this
# case the value of the NAME field for the clicked county.
county_click <- eventReactive(input$map_shape_click, {
x <- input$map_shape_click
y <- x$id
return(y)
})
# Here, we update our drop-down menu based on the county clicked.
observe({
updateSelectInput(session, 'county', selected = county_click())
})
# Here, we generate a new map based on the county click.  We remove the old
# highlighted county, then add the new one using the same styling we did before.
observe({
wamap <- leafletProxy('map', session) %>%
removeShape('sel_cty') %>%
addPolygons(data = selected_county(), fill = FALSE, color = '#FFFF00',
opacity = 1, layerId = 'sel_cty') %>%
fitBounds(lng1 = bbox(selected_county())[1],
lat1 = bbox(selected_county())[2],
lng2 = bbox(selected_county())[3],
lat2 = bbox(selected_county())[4])
})
# This is just an example of the output that can be generated.
# As you've changed the value for NAME - in this case the
# name of the county - it could be passed to a reactive expression to subset another
# dataset by county and then create a custom county plot.
output$expression <- renderPrint({
paste0('You clicked on ', input$county, '!  Pass me to a reactive expression!')
})
}
# Run the application
shinyApp(ui = ui, server = server)
install.packages("trackeR")
library(trackeR)
vignette("trackeR", package = "trackeR")
filepath <- system.file("extdata", "2013-06-08-090442.TCX", package = "trackeR")
filepath
runDF <- readTCX(file = filepath, timezone = "GMT")
str(runDF)
runTr0 <- trackeRdata(runDF)
runTr0
runTr1 <- readContainer(filepath, type = "tcx", timezone = "GMT")
runTr1
data("runs", package = "trackeR")
runs
str(runs)
runs[27]
str(runs[27])
runs[27][1]
runs[27]
str(runs[27])
names(runs[27])
leafletRoute(runs, session = 8:13)
leafletRoute
str(runs)
runs[1]
str(runs[1])
runs[1]['longitude']
runs[1][[1]]
runs[1][[1]]['longitude']
str(runs[1][[1]])
str(runs[1][[1]][1])
str(runs[1][[1]][[1]])
str(runs)
runs[[1]]
names(runs[[1]])
a <- runs[[1]]
str(a)
a[,1]
a <- as.data.frame(runs[[1]])
a$latitude
runsSummary <- summary(runs)
runsSummary
names(runs[[1]])
head(runs[[1]])
runsSummary
summary
runs[1:4]
dProfile <- distributionProfile(runs, session = 1:4, what = "speed",
grid = list(speed = seq(0, 12.5, by = 0.05)))
dProfile
ui <- basicPage(
plotOutput("plot"),
sliderInput("bins", "Number of bins:", 1, 50, 20)
)
server <- function(input, output) {
output$plot <- renderPlot({
hist(faithful$waiting, breaks = input$bins)
})
}
shinyApp(ui, server)
faithful$waiting
faithful$waiting
faithful
ui <- basicPage(
plotOutput("plot"),
sliderInput("bins", "Number of bins:", 1, 50, 20)
)
server <- function(input, output) {
output$plot <- renderPlot({
hist(faithful$waiting, breaks = input$bins)
})
}
shinyApp(ui, server)
shinyApp(ui, server)
ui <- basicPage(
plotOutput("plot1", click = "plot_click", width = 400),
verbatimTextOutput("info")
)
server <- function(input, output) {
output$plot1 <- renderPlot({
plot(mtcars$wt, mtcars$mpg)
})
output$info <- renderText({
paste0("x=", input$plot_click$x, "\n",
"y=", input$plot_click$y)
})
}
shinyApp(ui, server)
shinyApp(ui, server)
ui <- basicPage(
plotOutput("plot1", click = "plot_click", width = 400),
verbatimTextOutput("info")
)
server <- function(input, output) {
output$plot1 <- renderPlot({
plot(mtcars$wt, mtcars$mpg)
})
output$info <- renderPrint({
row <- nearPoints(mtcars, input$plot_click,
xvar = "wt", yvar = "mpg",
threshold = 5, maxpoints = 1)
cat("Nearest point within 5 pixels:\n")
print(row)
})
}
shinyApp(ui, server)
ui <- basicPage(
plotOutput("plot1", click = "plot_click", width = 400)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
mtc <- mtcars[, c("wt", "mpg")]
if (!is.null(input$plot_click)) {
mtc <- rbind(mtc,
data.frame(wt = input$plot_click$x, mpg = input$plot_click$y)
)
}
plot(mtc$wt, mtc$mpg)
})
}
shinyApp(ui, server)
ui <- basicPage(
plotOutput("plot1", click = "plot_click", width = 400)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
mtc <- mtcars[, c("wt", "mpg")]
if (!is.null(input$plot_click)) {
mtc <- rbind(mtc,
data.frame(wt = input$plot_click$x, mpg = input$plot_click$y)
)
}
plot(mtc$wt, mtc$mpg)
})
}
shinyApp(ui, server)
ui <- basicPage(
plotOutput("plot1", click = "plot_click", width = 400)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
mtc <- mtcars[, c("wt", "mpg")]
if (!is.null(input$plot_click)) {
mtc <- rbind(mtc,
data.frame(wt = input$plot_click$x, mpg = input$plot_click$y)
)
}
plot(mtc$wt, mtc$mpg)
})
}
shinyApp(ui, server)
ui <- basicPage(
plotOutput("plot1", click = "plot_click", width = 400)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
mtc <- mtcars[, c("wt", "mpg")]
if (!is.null(input$plot_click)) {
mtc <- rbind(mtc,
data.frame(wt = input$plot_click$x, mpg = input$plot_click$y)
)
}
plot(mtc$wt, mtc$mpg)
})
}
shinyApp(ui, server)
ui <- basicPage(
plotOutput("plot1", click = "plot_click", width = 400)
)
server <- function(input, output) {
vals <- reactiveValues(mtc = mtcars[, c("wt", "mpg")])
observeEvent(input$plot_click, {
vals$mtc <- rbind(vals$mtc,
data.frame(wt = input$plot_click$x, mpg = input$plot_click$y)
)
})
output$plot1 <- renderPlot({
plot(vals$mtc$wt, vals$mtc$mpg)
})
}
shinyApp(ui, server)
ui <- fluidPage(
# Some custom CSS for a smaller font for preformatted text
tags$head(
tags$style(HTML("
pre, table.table {
font-size: smaller;
}
"))
),
fluidRow(
column(width = 6,
# In a plotOutput, passing values for click, dblclick, hover, or brush
# will enable those interactions.
plotOutput("plot1", height = 350,
# Equivalent to: click = clickOpts(id = "plot_click")
click = "plot_click",
dblclick = dblclickOpts(
id = "plot_dblclick"
),
hover = hoverOpts(
id = "plot_hover"
),
brush = brushOpts(
id = "plot_brush"
)
)
)
),
fluidRow(
column(width = 3,
verbatimTextOutput("click_info")
),
column(width = 3,
verbatimTextOutput("dblclick_info")
),
column(width = 3,
verbatimTextOutput("hover_info")
),
column(width = 3,
verbatimTextOutput("brush_info")
)
)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
ggplot(mtcars, aes(wt, mpg)) + geom_point()
})
output$click_info <- renderPrint({
cat("input$plot_click:\n")
str(input$plot_click)
})
output$hover_info <- renderPrint({
cat("input$plot_hover:\n")
str(input$plot_hover)
})
output$dblclick_info <- renderPrint({
cat("input$plot_dblclick:\n")
str(input$plot_dblclick)
})
output$brush_info <- renderPrint({
cat("input$plot_brush:\n")
str(input$plot_brush)
})
}
shinyApp(ui, server)
# Example usage:
# lmGadget(mtcars, "wt", "mpg")
#
# Returns a list with two items:
#   $data: Data with excluded rows removed.
#   $model: lm (model) object.
lmGadget <- function(data, xvar, yvar) {
library(shiny)
library(miniUI)
library(ggplot2)
ui <- miniPage(
gadgetTitleBar("Interactive lm"),
miniContentPanel(
fillRow(flex = c(NA, 1),
fillCol(width = "100px",
selectInput("degree", "Polynomial degree", c(1, 2, 3, 4))
),
plotOutput("plot1",
height = "100%",
click = "plot1_click",
brush = brushOpts(
id = "plot1_brush"
)
)
)
),
miniButtonBlock(
actionButton("exclude_toggle", "Toggle points"),
actionButton("exclude_reset", "Reset")
)
)
server <- function(input, output) {
# For storing which rows have been excluded
vals <- reactiveValues(
keeprows = rep(TRUE, nrow(data))
)
output$plot1 <- renderPlot({
req(input$degree)
formula <- as.formula(paste0("y ~ poly(x, degree = ", input$degree, ")"))
# Plot the kept and excluded points as two separate data sets
keep    <- data[ vals$keeprows, , drop = FALSE]
exclude <- data[!vals$keeprows, , drop = FALSE]
ggplot(keep, aes_string(xvar, yvar)) +
geom_point(size = 3) +
geom_smooth(method = lm, formula = formula, fullrange = TRUE, color = "gray50") +
geom_point(data = exclude, fill = NA, color = "black", size = 3, alpha = 0.25) +
coord_cartesian(xlim = range(data[[xvar]]), ylim = range(data[[yvar]])) +
theme_bw(base_size = 14)
})
# Toggle points that are clicked
observeEvent(input$plot1_click, {
res <- nearPoints(data, input$plot1_click, allRows = TRUE)
vals$keeprows <- xor(vals$keeprows, res$selected_)
})
# Toggle points that are brushed, when button is clicked
observeEvent(input$exclude_toggle, {
res <- brushedPoints(data, input$plot1_brush, allRows = TRUE)
vals$keeprows <- xor(vals$keeprows, res$selected_)
})
# Reset all points
observeEvent(input$exclude_reset, {
vals$keeprows <- rep(TRUE, nrow(data))
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Replace x and y in the formula with the values in xvar and yvar
formula <- as.formula(paste0(yvar, " ~ poly(", xvar, ", degree = ", input$degree, ")"))
keep_data <- data[vals$keeprows, , drop = FALSE]
# Return the kept points.
stopApp(
list(
data = keep_data,
model = lm(formula, keep_data)
)
)
})
}
runGadget(ui, server)
}
lmGadget
lmGadget()
install.packages("miniUI")
lmGadget()
lmGadget(mtcars, )
lmGadget(mtcars, mpg,cyl)
lmGadget(mtcars, 'mpg','cyl')
R> filepath <- system.file("extdata", "2013-06-08-090442.TCX",
+    package = "trackeR")
R> runDF <- readTCX(file = filepath, timezone = "GMT")
R> str(runDF)
filepath <- system.file("extdata", "2013-06-08-090442.TCX",
+    package = "trackeR")
runDF <- readTCX(file = filepath, timezone = "GMT")
str(runDF)
library(trackeR)
filepath <- system.file("extdata", "2013-06-08-090442.TCX",
+    package = "trackeR")
library(trackeR)
filepath <- system.file("extdata", "2013-06-08-090442.TCX",
package = "trackeR")
runDF <- readTCX(file = filepath, timezone = "GMT")
str(runDF)
runDF
library(trackeR)
filepath <- system.file("extdata", "2013-06-08-090442.TCX",
package = "trackeR")
library(trackeR)
filepath <- system.file("extdata", "2013-06-08-090442.TCX", package = "trackeR")
filepath
runTr1 <- readContainer(filepath, type = "tcx", timezone = "GMT")
runTr1
plot()
plot
methods(plot)
plot.trackeRdataZones
plot.trackeRdataZones*
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages("rstudioapi")
rstudioapi::isAvailable("0.99.149")
devtools::install_github("hadley/devtools")
dataPoisson <- c(4, 5, 2)
library(fitdistrplus)
library(logspline)
dataPoisson <- c(4, 5, 2)
fit.poisson <- fitdist(dataPoisson, 'pois')
fitdist(dataPoisson, 'pois')
fit.poisson <- fitdist(dataPoisson, 'pois')
summary(fit.poisson)
fitdist(dataPoisson, 'pois')
setwd("~/trackeR")
devtools::load_all()
startApp()
dashboardPage()
?dashboardPage
setwd("~/trackeR/R")
devtools::load_all()
devtools::load_all()
startApp()
